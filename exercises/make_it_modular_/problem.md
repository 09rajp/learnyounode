今回の問題は前回のとよく似ていますが、今回は **modules**の概念を使いましょう。問題の解決には2つのファイルが必要になります。

ファイルの拡張子でフィルターして与えられたディレクトリーからファイルのリストを出力するプログラムを書いてください。1つ目の引数はディレクトリー名、2つ目は拡張子です。1行に1ファイルずつコンソールに出力してください。非同期I/Oを使ってください。

アプリの多文は一つの **module** ファイルを書いてください。その module が一つのメソードをexportするのが必要です。そのメソードは三つの引数があります：フォルダー名、ファイルの拡張子、ASYNCのコールバックメソード。全くこの順番。Module のファイル拡張子はアプリがもらっているファイル拡張子と全く同じバリューをつかってください。例えば: RegExpにラップや"."をつけるのがダメです。

コールバック関数は Node の習慣的なイディオムを使って呼び出してください：(err, data)。このイディオムで言うとエラーのない場合は1つ目の引数（err）はnullです。2つ目にはデータが入っています。今回の問題の場合にはファイルリストのArrayです。
エラーの場合（つまり：fs.readdir()で問題があった場合）は、そのエラーだけを1つ目の引数としてコールバック関数に渡してください。

コンソールへの出力は module ではなく、本体のプログラムでのみ出力してください。

エラーの場合はわかりやすいエラーメッセージを出力してください。

約定；つまり、あなたの module は、以下の4点の制約を守ってください。

1. 正しく引数を取る関数を export してください。
2. エラーか何らかのデータを引数に取るコールバックを1度だけ呼び出してください。
3. 他には何も変えないでください（グローバル変数や標準出力）
4. 発生する可能性のあるエラーは全てコールバック関数に渡してください。

この制約の良いところはこれを守っている module であれば誰にでも扱えることです。

----------------------------------------------------------------------
## ヒント

フォルダーを読むフィルタする module を書くためにそれを新しいファイルに書いてください。*一つのメソード*を*export*するために`module.exports`、この例と同じように：

```js
module.exports = function (args) { /* ... */ }
```

あるいは名前があるメソードを名前を使ってexportしてもいいです。

```js
function hoge() {
    /* ... */
}

module.exports = hoge
```

あなたの新いModuleを使うために`require()`を使ってください。 `require('fs')`が`fs` をロードすると同じように。ただ、一つの大切な違いはローカルのModuleのために'./'を使ってください。あなたのModuleの名前は`mymodule.js`だったらこのように使ってください:

```js
var mymodule = require('./mymodule.js')
```

（メモ：`'.js'`の拡張子はこの場合が必要ではありません。他のコードではそれはよく省略しています。）

今は`mymodule`の変数を使ってにそのModuleに書いてある `module.exports`のObjectをアクセスできます。一つのメソードだけをexportしてあるから`mymodule`が呼べるメソードです！

イディオムのエラーチェックとreturnを忘れないでください：

```js
function bar (callback) {
  foo(function (err, data) {
    if (err)
      return callback(err) // early return

    // ... no error, continue doing cool things with `data`

    // all went well, call callback with `null` for the error argument

    callback(null, data)
  })
}
```

----------------------------------------------------------------------
