今回の問題は前とよく二ていますが今回は**Module**を使いましょうか？ソリューションのために二つのファイルが必要です。

拡張子のフィルタを使ってファイルリストをコンソールに出すアプリを書いてください。一つ目の引数はフォルダーだし二つ目はファイルの拡張子です。コンソールにそのリストを出してください。一つのファイル名は一行。**ASYNC**I/Oが要件です。

アプリの多文は一つの**Module**ファイルを書いてください。そのModuleが一つのメソードをexportするのが必要です。そのメソードは三つの引数があります：フォルダー名、ファイルの拡張子、ASYNCのコールバックメソード。全くこの順番。Moduleのファイル拡張子はアプリがもらっているファイル拡張子と全く同じバリューをつかってください。例えば:RegExpにラップや"."をつけるのがダメです。

コールバックはNodeのイディオムを守らないといけません：```(err, data)```。このイディオムならエラーのない場合は一つ目の引数（err）は```null```です。二つ目にはデータが入っています。今回の問題の場合にはファイルリストのArrayです。
エラーの場合（例えば：```fs.readdir()```が問題の場合）そのエラーだけを一つ目の引数として渡してください。

そのModuleはコンソールに出力に書くじゃだめです。アプリのファイルだけが出力していいです。

エラーの場合はわかりやすいエラーメッセージを出力してください。

約定；つまり、あなたのModuleはこの四つの店を守らないといけません。

1. 説明した引数だけがある一つもメソードをexportしてください
2. コールバックは一回だけを説明したように呼んでください。
3. 他のことを変えないでください（グローバル変数とかStdout)
4. 全ての可能性があるエラーをチェックしてコールバックに渡してください

約定はアドバンテージがあります。Moduleは約定を守るとその約定がしている人はそのままにあなたのModuleが使えます。

----------------------------------------------------------------------
## ヒント

フォルダーを読むフィルタするModuleを書くためにそれを新しいファイルに書いてください。*一つのメソード*を*export*するために`module.exports`、この例と同じように：

```js
module.exports = function (args) { /* ... */ }
```

あるいは名前があるメソードを名前を使ってexportしてもいいです。

```js
function hoge() {
    /* ... */
}

module.exports = hoge
```

あなたの新いModuleを使うために`require()`を使ってください。 `require('fs')`が`fs` をロードすると同じように。ただ、一つの大切な違いはローカルのModuleのために'./'を使ってください。あなたのModuleの名前は`mymodule.js`だったらこのように使ってください:

```js
var mymodule = require('./mymodule.js')
```

（メモ：`'.js'`の拡張子はこの場合が必要ではありません。他のコードではそれはよく省略しています。）

今は`mymodule`の変数を使ってにそのModuleに書いてある `module.exports`のObjectをアクセスできます。一つのメソードだけをexportしてあるから`mymodule`が呼べるメソードです！

イディオムのエラーチェックとreturnを忘れないでください：

```js
function bar (callback) {
  foo(function (err, data) {
    if (err)
      return callback(err) // early return

    // ... no error, continue doing cool things with `data`

    // all went well, call callback with `null` for the error argument

    callback(null, data)
  })
}
```

----------------------------------------------------------------------
